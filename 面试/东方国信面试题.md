c++
new malloc区别
堆、栈
字符串存储区域
内存区域划分
多态是什么
数据库各种机制了解
分布式原理paxios、CAP理论
GP的分区容错性
笔试题最后一道





# c++基础知识

malloc（）函数的工作机制 
　　malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc

函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大

小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并

将剩下的那块（如果有的话）返回到连接表上。调用free函数时，它将用户释放的内存块连接到空闲链上。到

最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以

满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们

进行整理，将相邻的小空闲块合并成较大的内存块。

#### a、new、malloc区别

1、new 分配内存同时会调用类的的构造函数，而delete也会调用析构函数

​      malloc只分配内存不会调用构造函数，free也不会调用析构函数

2、内存申请失败处理方式

​      new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。

3、内存区域

　　new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，new就可以不位于堆中。

 

**PS:**

 在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区；

 在C中，C内存区分为堆、栈、全局/静态存储区、常量存储区；



b、内存区域划分

**一、首先进程地址空间的 1G 内核空间是给操作系统使用的，我们用户是没有操作权限的。**
**二、剩下的 3G 内存空间中，分为了栈区、内存映射段、堆区、数据段、bss段、代码段**
**1）栈区：这里的栈和数据结构的栈并不相同，数据结构的栈是一种后进先出的数据结构，而内存划分的栈是操作系统按照栈的特性，给用户划分出的内存区间。**
   **栈区一般存放：函数体的局部变量、函数调用期间的所有参数压栈、函数的返回值**
**注意栈区这段内存是由操作系统自己维护的，所以函数结束，在栈上的空间会由操作系统自己回收。**

**2）堆区：用户所操作的内存就是堆上的空间，用户可以使用 malloc / calloc / realloc / new 申请堆上的空间，但是用户申请堆上的空间必须自己手动释放，不然会造成内存泄漏。**

**3）内存映射段：里面存放 动态库 / 静态库，以及文件映射，匿名映射等等一切有依赖性的东西都在这段区域**

**4）一个程序本质上都是由 bss段、数据段、代码段组成的**
   **数据段：存放全局变量、静态类型的变量。当代码编译完后，在可执行程序这个文件中已经把这些数据的空间划分好了，这种类型的数据，在程序运行以前，操作系统就将数据段中的数据加载到内存了。也就是说在进入 main 函数之前这些数据已经划分号空间了。**

   **bss段：其实在 C 语言中，数据段中还有一个 bss 段，这里面存放的是未初始化的全局变量和静态数据，而数据段中存放的是已经初始化过的全局变量和静态数据。数据段中的所有数据已经划分好空间了，但是 bss 段并没有给其中的数据划分空间。**

   **代码段：存放可执行代码，以及只读常量(字符串常量等等)。这段内存是只读的。**



结论：字符串存储在代码段。



C++面向对象三态

封装

继承

多态

**多态**按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。

C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。

c++多态是通过虚函数实现的。

**虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。

我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。
#### 1、三大范式

第一范式：每个列都不可以再拆分。

第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。主键，唯一地标识列。

第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。消除冗余。

#### 2、乐观锁、悲观锁

#### 悲观锁

> 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
>
> 适用于写多读少场景。
>
> #### 乐观锁
>
> > 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。
> >
> > 适用于写少读多的场景。

#### 3、幻读

同一个事务里，后一次查询读到了前一次查询未读到的数据。

如何解决幻读

新插入的行导致的幻读。

mysql 间隙锁、PG有个version字段。

脏读

不可重复读

#### 4、ACID

原子性：一个事务中的所有操作，要么全部成功，要么全部失败，不允许再分割。

一致性：执行数据前后，数据保持一致，多个事务对于同一个数据读取的结果是相同的。

隔离性：各个并发事务之间互不干扰。

持久性：一个事务被提交之后，对于数据库的影响是持久的。

#### 5、最左匹配原则

where子句使用的列放在最左边，索引匹配时遇到范围比较（>,>=,<,<=,between、like）时会停止匹配，不会再匹配它右边的=。



#### 6、B树/B+树，数据库为什么用B+树

B+树非叶子节点只存放键，叶子节点存放值，叶子节点之间相连。

B树内部节点既存放键又存放值。

全数据遍历时B+树只需要遍历所有叶子节点，相比B树要快。

B+树只存放键，因此可以存放更多的节点，有利于更快地缩小查询范围。

B+树查询稳定。

B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据。

### 7、聚簇索引

索引和元组放在一起称为聚簇索引，反之，索引指向元组称之为非聚簇索引（也叫二级索引）。

应用场景区别

### 8、联合索引是什么？为什么需要注意联合索引中的顺序？

MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

具体原因为:

MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。

当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。

锁机制

表级、行级、共享锁、排他锁

#### 9、视图，使用场景、优缺点

视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。

下面是视图的常见使用场景：

- 重用SQL语句；
- 简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；
- 使用表的组成部分而不是整个表；
- 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；
- 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。

### 视图的优点

1. 查询简单化。视图能简化用户的操作
2. 数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护
3. 逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性

### 视图的缺点

1. 性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。
2. 修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的。